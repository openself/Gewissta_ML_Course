"0","library(partykit)"
"0","treetable <- function(party_tree) {"
"0","  "
"0","  df_list <- list()"
"0","  var_names <-  attr(party_tree$terms, ""term.labels"")"
"0","  var_levels <- lapply(party_tree$data, levels)"
"0","  "
"0","  walk_the_tree <- function(node, rule_branch = NULL) {"
"0","    # проходим структуру разбиений дерева (рекурсивная функция)"
"0","    # извлекаем правила для каждой ветви"
"0","    if(missing(rule_branch)) {"
"0","      rule_branch <- setNames(data.frame(t(replicate(length(var_names), NA))), var_names)"
"0","      rule_branch <- cbind(rule_branch, nodeId = NA)"
"0","      rule_branch <- cbind(rule_branch, predict = NA)"
"0","    }"
"0","    if(is.terminal(node)) {"
"0","      rule_branch[[""nodeId""]] <- node$id"
"0","      rule_branch[[""predict""]] <- predict_party(party_tree, node$id, type=""prob"") "
"0","      "
"0","      "
"0","      df_list[[as.character(node$id)]] <<- rule_branch"
"0","    } else {"
"0","      for(i in 1:length(node)) {"
"0","        rule_branch1 <- rule_branch"
"0","        val1 <- decision_rule(node,i)"
"0","        rule_branch1[[names(val1)[1]]] <- val1"
"0","        walk_the_tree(node[i], rule_branch1)"
"0","      }"
"0","    }"
"0","  }"
"0","  "
"0","  decision_rule <- function(node, i) {"
"0","    # возвращаем правила разбиения в датафрейм вместе с названиями переменных и значениями"
"0","    var_name <- var_names[node$split$varid[[1]]]"
"0","    values_vec <- var_levels[[var_name]][ node$split$index == i]"
"0","    values_txt <- paste(values_vec, collapse = "", "")"
"0","    return( setNames(values_txt, var_name))"
"0","  }"
"0","  walk_the_tree(party_tree$node)"
"0","  res_table <- Reduce(rbind, df_list)"
"0","  return(res_table)"
"0","}"
"0","table <- treetable(chd)"
"0","table[1:14]"
